# 通用通信（comm）组件

<img src = "https://img.shields.io/badge/version-1.0.0-green"><sp> <img src = "https://img.shields.io/badge/author-Caikunzhen-lightgrey">

## 使用通信类别

该组件用于统一常见的通信方式，同时通过封装使使用者能更加简便使用相应的通信，减少使用者踩坑的情况。目前已实现的通信协议包括：CAN、FDCAN(Classic)、UART。

## 使用准备

使用前序要做一下准备：

- 确保 `config.cmake` 文件中设置 `use_hwcomponents_devices_comm` 选项为 `ON`，若为 `OFF` 则根据组件配置需求在 `CMakeLists.txt` 文件中重配置为 `ON`。

## 1. 组成说明

为统一通信方式，通信组件组件被分为**通信对象**（发送端 `Transmitter` 和接收端 `Receiver`）与**通信管理器**（发送管理器 `TxMgr` 和接收管理器 `RxMgr`）。

### Transmitter

用于统一发送端，需要通过通用通信组件发送的类需**继承**该接口类，需重写 `txId`（用于获取发送 ID）、`encode`（用于编码待发送的数据，建议在其中统计编码成功与编码失败的次数，**同时要求该方法仅对需要编码的部分进行处理**）和 `txCpltCallback`（发送完成回调，建议用于统计发送成功的次数，通过与编码成功次数对比可用于判断编码成功的消息是否都成功发出）。

### Receiver

用于统一接收端，需要通过通用通信组件接收的类需要**继承**该接口类，需要重写 `rxId`（用于获取接收 ID）、`decode`（用于解码收到的数据，建议在其中统计解码成功与解码失败的次数，根据二者可以判断是否有收到对应 ID 的数据以及收到的正确数据是否有更新）。

### TxMgr

用于实现某外设的发送功能，具体的外设如 CAN、UART 均**继承**于该虚基类。

- `addTransmitter` 方法用于添加通过对应外设发送数据的发送端（**注意发送管理器内部仅保留添加的发送端的指针，因此在使用发送管理器期间需保证添加的发送端一直存在，同时已有的指针不会被进一步添加**）。
- `setTransmitterNeedToTransmit` 方法用于将发送器对应的报文**设置为需要发送状态**。
- `startTranmit` 方法用于在**所有发送端添加完毕后**开启发送，开启后**相同 ID** 的发送端将被依次调用 `encode` 方法对**同一条**报文进行编码，完成后再将报文通过外设发出，为适配各个发送器可能有不同的发送频率或是交替发送的特殊需求，因此**每次要发送数据时都需要先调用 `setTransmitterNeedToTransmit` 方法再调用发送开启方法**，同时对于某个 ID 对应的报文，只有**所有发送端编码均成功**，发送管理器才会认为该报文处于**可发送状态**，意味着当某条报文对应的发送端只要有一个编码失败则该条报文便不会被发出。
- `getRemainMsgNum` 方法用于获取目前待发送的报文数量（**不一定是发送端数量**），建议在调试期间在每次循环添加发送端前调用该方法，如果发现待发送报文数量**不为零**，说明上一次循环添加的报文**未能及时全部发出**，此时应考虑相应的解决方法。

> 在最初的设计中本计划当某 ID 对应报文发送完成后便将对应的发送端从发送管理器内部删除，但在实际的测试中，当下次循环开始时若仍有未发完的报文时，容易产生**一个中断在添加发送器而另一个中断在删除发送器的情况**，因此及其容易导致**硬件错误**，为此最终方案改为额外增加一个用于记录某条 ID 报文是否需要发送，而不对发送完成的发送端进行删除，由此避免反复增加删除的问题。

### RxMgr

用于实现某外设的接收功能，具体的外设如 CAN、UART 均**继承**于该虚基类。

- `addReceiver` 方法用于添加通过对应外设接收数据的接收端（**注意接收管理器内部仅保留添加的接收端的指针，因此在使用接收管理器期间需保证添加的接收端一直存在，同时已有的指针不会被进一步添加**）。
- `startReceive` 方法用于开启接收，只需调用一次即可。

在对应的派生类中，当对应外设接受到数据后，会根据接收到数据的 ID，以此调用对应 ID 的**所有**接收器的 `decode` 方法进行数据解包。

## 2. CAN

### 外设驱动配置

![CAN 配置](通用通信组件.assets/2024-06-30%20133947.png)

在使用 CAN 进行通信时，使用 CubeMx 配置时先将 CAN 的引脚配置完成，然后调整 `Perscaler`、`Time Quanta in Bit Segment 1` 与 `Time Quanta in Bit Segment 2` 使得 `Baud Rate` 为所需波特率（常见为 1Mb/s，**注意配置中 Seg1/(Seg1+Seg2) 应大于0.2，否者在实际的使用中及其容易导致通信出错**）。

![CAN 中断配置](./通用通信组件.assets/2024-06-30%20134734.png)

配置完成后开启发送中断与对应的接受中断（当使用多个 CAN 接收时建议平均分配到两个接收中断上，如 CAN1 使用 `RX0 interrupts`，CAN2 使用 `RX1 interrupt`）。

### 使用示例

以电机组件为例，电机类同时继承了 `Transmitter` 与 `Receiver`。

```cpp
namespace hw_comm = hello_world::comm;
namespace hw_motor = hello_world::motor;

hw_comm::CanRxMgr* can_rx_mgr_ptr = nullptr;
hw_comm::CanTxMgr* can_tx_mgr_ptr = nullptr;

hw_motor::Motor* motor_ptr_ls[8] = {nullptr};

void Init(void)
{
    /* FIFO 与 CubeMx 中 RX 中断对应 */
    can_rx_mgr_ptr = new comm::CanRxMgr(&hcan1, comm::CanRxMgr::RxType::kFifo0);
    can_tx_mgr_ptr = new comm::CanTxMgr(&hcan1);

    for (uint8_t i = 0; i < 8; i++) {
        /* 创建电机 */
        motor_ptr_ls[i] = motor::A1(i + 1);

        /* 将电机添加到对应 CAN 的发送、接受管理器中 */
        can_tx_mgr_ptr->addTransmitter(motor_ptr_ls[i]);
        can_rx_mgr_ptr->addReceiver(motor_ptr_ls[i]);
    }

    /* 配置过滤器、开启接收同时开启 CAN 外设 */
    can_rx_mgr_ptr->filterInit();
    can_rx_mgr_ptr->startReceive();
    HAL_CAN_Start(&hcan1);
}

/* 以 1ms 为周期调用的函数 */
void Loop1ms(void)
{
    /*
        设置电机命令
    */

    /* 将电机设置为发送状态 */
    for (uint8_t i = 0; i < 8; i++) {
        can_tx_mgr_ptr->setTransmitterNeedToTransmit(motor_ptr_ls[i]);
    }

    /* 开启发送 */
    can_tx_mgr_ptr->startTransmit();
}

/* 接收回调函数 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan)
{
    can_rx_mgr_ptr->rxFifoMsgPendingCallback(hcan);
}

/* 发送回调函数 */
void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef* hcan)
{
    can_tx_mgr_ptr->txMailboxCompleteCallback(hcan);
}

void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef* hcan)
{
    can_tx_mgr_ptr->txMailboxCompleteCallback(hcan);
}

/* 错误回调函数 */
void HAL_CAN_ErrorCallback(CAN_HandleTypeDef* hcan)
{
    can_tx_mgr_ptr->errorCallback(hcan);
}
```

### 使用说明

#### CanTxMgr

该类用于实现 CAN 的数据发送

- `txMailboxCompleteCallback` 需放于 `HAL_CAN_TxMailboxXCompleteCallback (X=1、2、3)` 回调函数中，用于在有空发送邮箱时开启发送。
- `errorCallback` 需放于 `HAL_CAN_ErrorCallback` 回调函数中，用于在报文无应答时发送下一条报文。
- `status` 用于获取 CAN 发送管理器状态，通过位置位表示状态。
- `getTxMailboxesFreeLevel` 用于获取发送邮箱的空闲数量。

#### CanRxMgr

该类用于实现 CAN 的数据接收

- `filterInit` 配置过滤器，为接收所有 ID 的报文，若有**进一步需求请自行配置**过滤器。
- `rxFifoMsgPendingCallback` 需放于 `HAL_CAN_RxFifoXMsgPendingCallback(X=0、1)` 回调函数中，用于在 CAN 外设获取到数据时进行数据处理。
- `status` 用于获取 CAN 发送管理器状态，通过位置位表示状态。

## 3. FDCAN

### 外设驱动配置

![FDCAN 配置](通用通信组件.assets/2024-07-01%20104811.png)

在使用 FDCAN 进行通信时，使用 CubeMx 配置时先将 FDCAN 的引脚配置完成，`Frame Format` 配置为 `Classic mode`，然后调整 `Nominal Perscaler`、`Nominal Time Seg1` 与 `Nominal Time Seg2` 使得 `Nominal Baud Rate` 为所需波特率（常见为 1Mb/s，**注意配置中 Seg1/(Seg1+Seg2) 应大于0.2，否者在实际的使用中及其容易导致通信出错**）。完成后将配置的参数分别填写到 `Data Prescaler`、`Data Time Seg1` 与 `Data Time Seg2`。

![FDCAN RAM配置](./通用通信组件.assets/2024-07-01%20110524.png)

进一步填写 `Basic Parameters` 中自 `Message Ram Offset` 起的部分。由于所有的 FDCAN 共用大小为 2560 个字的 RAM，因此需要根据实际需要进行配置，同时保证各个 FDCAN 的 RAM 部分**不发生交叠**（由 `Message Ram Offset`决定）。

> 建议的配置方法为：
> 1. 调整 `Message Ram Offset` 使每个 FDCAN 基本分到一样的空间，以使用两个 FDCAN 为例，FDCAN1 的 `Message Ram Offset` 配置为 0，FDCAN2 的 `Message Ram Offset` 配置为 1280。
> 2. 若使用组件提供的 `filterInit` 进行滤波器配置，则将 `Std Filters Nbr` 配置为 1，`Rx Fifo0 Elmts Nbr` 或 `Rx Fifo1 Elmts Nbr` （根据实际需求配置，但建议不同的 FDCAN 使用不同的 FIFO）配置为 8 左右，`Tx Fifo Queue Elmts Nbr` 配置为 8 左右。

![FDCAN 中断配置](./通用通信组件.assets/2024-07-01%20111915.png)

配置完成后开启中断（当使用多个 FDCAN 时建议平均分配到两个中断上，如 FDCAN1 使用 Interrupt 0，FDCAN2 使用 Interrupt 1）。

### 使用示例

以电机组件为例，电机类同时继承了 `Transmitter` 与 `Receiver`。

```cpp
namespace hw_comm = hello_world::comm;
namespace hw_motor = hello_world::motor;

hw_comm::FdCanRxMgr* fdcan_rx_mgr_ptr = nullptr;
hw_comm::FdCanTxMgr* fdcan_tx_mgr_ptr = nullptr;

hw_motor::Motor* motor_ptr_ls[8] = {nullptr};

void Init(void)
{
    fdcan_rx_mang_ptr = new comm::FdCanRxMgr(&hfdcan1, comm::FdCanRxMgr::RxType::kFifo0);
    fdcan_tx_mang_ptr = new comm::FdCanTxMgr(&hfdcan1);

    /* Interrupt Line 需与 CubeMx 中勾选的中断相对应 */
    fdcan_rx_mang_ptr->configInterruptLines(comm::FdCanRxMgr::ItLine::k0);
    fdcan_tx_mang_ptr->configInterruptLines(comm::FdCanTxMgr::ItLine::k0);

    for (uint8_t i = 0; i < 8; i++) {
        /* 创建电机 */
        motor_ptr_ls[i] = motor::A1(i + 1);

        /* 将电机添加到对应 FDCAN 的接受管理器中 */
        fdcan_tx_mgr_ptr->addTransmitter(motor_ptr_ls[i]);
        fdcan_rx_mgr_ptr->addReceiver(motor_ptr_ls[i]);
    }

    /* 配置过滤器、开启接收同时开启 FDCAN 外设 */
    fdcan_rx_mgr_ptr->filterInit();
    fdcan_rx_mgr_ptr->startReceive();
    HAL_FDCAN_Start(&fdhcan1);
}

/* 以 1ms 为周期调用的函数 */
void Loop1ms(void)
{
    /*
        设置电机命令
    */

    /* 将电机设置为发送状态 */
    for (uint8_t i = 0; i < 8; i++) {
        fdcan_tx_mgr_ptr->setTransmitterNeedToTransmit(motor_ptr_ls[i]);
    }

    /* 开启发送 */
    fdcan_tx_mgr_ptr->startTransmit();
}

/* 接收回调函数 */
void HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef* hfdcan, uint32_t RxFifo0ITs)
{
    fdcan_rx_mang_ptr->rxFifoCallback(hfdcan, RxFifo0ITs);
}

/* 发送回调函数 */
void HAL_FDCAN_TxFifoEmptyCallback(FDCAN_HandleTypeDef* hfdcan)
{
    fdcan_tx_mang_ptr->txFifoEmptyCallback(hfdcan);
}
```

### 使用说明

#### FdCanTxMgr

该类用于实现 FDCAN 的数据发送

- `configInterruptLines` 用于配置中断线，需与 CubeMx 的中断配置**相对应**。**必须在第一次开启发送前进行**。
- `txFifoEmptyCallback` 需放于 `HAL_FDCAN_TxFifoEmptyCallback` 回调函数中，用于在有空发送队列时开启发送。
- `status` 用于获取 FDCAN 发送管理器状态，通过位置位表示状态。
- `getTxMailboxesFreeLevel` 用于获取发送邮箱的空闲数量。

#### FdCanRxMgr

该类用于实现 FDCAN 的数据接收

- `filterInit` 配置过滤器，为接收所有 ID 的报文，若有**进一步需求请自行配置**过滤器。
- `configInterruptLines` 用于配置中断线，需与 CubeMx 的中断配置**相对应**。**必须在开启接收前进行**。
- `rxFifoCallback` 需放于 `HAL_FDCAN_RxFifoXCallback(X=0、1)` 回调函数中，用于在 FDCAN 外设获取到数据时进行数据处理。
- `status` 用于获取 FDCAN 发送管理器状态，通过位置位表示状态。

## 4. UART

### 外设驱动配置

![UART DMA 配置](通用通信组件.assets/2024-07-01%20125449.png)

在使用 UART 进行通信时，使用 CubeMx 配置时先将 UART 的引脚配置完成，`Basic Parameters` 中的参数根据实际需要配置。然后进行 DMA 配置，根据需要配置发送与接收的 DMA，**发送**的 DMA 的 `Mode` 配置为 `Normal`，**接收**的 DMA 的 `Mode` 配置为 `Circular`，二者的 `Priority` 建议配置为 `High` 或 `Very High`。

![UART 中断配置](./通用通信组件.assets/2024-07-01%20130017.png)

进一步配置 UART 的中断，开启 UART 的全局中断，同时尽可能保证 DMA 接收中断的 `Preemption Priority` 与 `Sub Priority` 值**低于** `global interrupt`（即**优先级更高**）

> 要求 DMA 接收中断优先级更高的原因在于当在中断中接收处理**耗时较长时**，容易导致 DMA 的半/全接收与 UART 的空闲中断**同时被挂起**的情况，在当前中断结束后，若二者的优先级相等，则空闲中断会优先触发，进而导致接收处理出现问题（绝大多数情况下半/全接收会在空闲中断前产生）。

### 使用示例

以遥控器组件及自定义通信类为例，遥控器类继承了 `Receiver`，自定义通信类同时继承了 `Transmitter` 与 `Receiver`。

假定自定义通信帧为**帧头+数据段+帧尾**，其中帧头（四字节）为 `0x3F 0x4F` + 接收 ID（uint_8） + 数据段长度（uint_8），帧尾（1字节）为 `0xFF`。

```cpp
namespace hw_comm = hello_world::comm;
namespace hw_rc = hello_world::remote_control;

class TxRx : public comm::Transmitter, public comm::Receiver
{
   public:
    TxRx(uint32_t tx_id, uint32_t rx_id)
        : Transmitter(), Receiver(), tx_id_(tx_id), rx_id_(rx_id) {}
    ~TxRx() {}

    virtual uint32_t txId(void) const override
    {
        return tx_id_;
    }

    virtual uint32_t rxId(void) const override
    {
        return rx_id_;
    }

    virtual bool encode(uint8_t* data, size_t* len) override
    {
        if (*len >= 8) {
            /* 帧头 */
            data[0] = 0x3F;
            data[1] = 0x4F;
            data[2] = tx_id_;  // 接收方ID
            data[3] = 0x03;    // 数据长度

            /* 数据段 */
            data[4] = 0xAA;
            data[5] = 0xBB;
            data[6] = 0xCC;

            /* 帧尾 */
            data[7] = 0xFF;

            *len = 8;

            encode_success_cnt_++;
            return true;
        } else {
            encode_fail_cnt_++;
            return false;
        }
    }

    virtual void txCpltCb(void) override
    {
        transmit_success_cnt_++;
    }

    virtual bool decode(const uint8_t* data, size_t len) override
    {
        /* 帧头帧尾校验 */
        if (data[0] == 0x3F && data[1] == 0x4F && data[2] == rx_id_ &&
            data[3] == len - 5 && data[len - 1] == 0xFF && data[3] <= 13) {
            memset(data_, 0, 13);
            memcpy(data_, data + 4, data[3]);
            decode_success_cnt_++;
            return true;
        } else {
            decode_fail_cnt_++;
            return false;
        }
    }

   private:
    uint32_t tx_id_ = 0;
    uint32_t rx_id_ = 0;

    uint8_t data_[13] = {0};

    uint8_t encode_success_cnt_ = 0;
    uint8_t encode_fail_cnt_ = 0;
    uint8_t transmit_success_cnt_ = 0;

    uint8_t decode_success_cnt_ = 0;
    uint8_t decode_fail_cnt_ = 0;
};

class DataProcesser : public hello_world::MemMgr
{
   public:
    static bool ProcessData(const uint8_t* rx_data, size_t rx_data_len,
                            size_t* rx_data_processed_len, uint32_t* id,
                            uint8_t* processed_data, size_t* processed_data_len)
    {
        for (size_t i = 0; i < rx_data_len; i++) {
            if (decodeByte(rx_data[i], processed_data, processed_data_len)) {
                *rx_data_processed_len = i + 1;
                *id = processed_data[2];
                *processed_data_len = processed_data[3] + 5;
                return true;
            }
        }

        return false;
    }

   private:
    enum class Fsm {
        kWaiForHeader,
        kWaitForData,
        kWaitForCheck,
    };

    DataProcesser() {}
    ~DataProcesser() {}

    static bool decodeByte(uint8_t byte, uint8_t* processed_data,
                            size_t* processed_data_len)
    {
        /* 数据溢出则直接重新接收 */
        if (*processed_data_len == tmp_data_idx_) {
            tmp_data_idx_ = 0;
            fsm_ = Fsm::kWaiForHeader;
        }

        /* 数据处理 */
        switch (fsm_) {
            case Fsm::kWaiForHeader:
                if (byte == 0x3F && tmp_data_idx_ == 0) {
                    processed_data[tmp_data_idx_++] = byte;
                } else if (byte == 0x4F && tmp_data_idx_ == 1) {
                    processed_data[tmp_data_idx_++] = byte;
                } else if (tmp_data_idx_ == 2 || tmp_data_idx_ == 3) {
                    processed_data[tmp_data_idx_++] = byte;
                    if (tmp_data_idx_ == 4) {
                        fsm_ = Fsm::kWaitForData;
                    }
                } else {
                    tmp_data_idx_ = 0;
                }
                break;
            case Fsm::kWaitForData:
                processed_data[tmp_data_idx_++] = byte;
                if (tmp_data_idx_ == processed_data[3] + 4) {
                    fsm_ = Fsm::kWaitForCheck;
                }
                break;
            case Fsm::kWaitForCheck:
                processed_data[tmp_data_idx_++] = byte;
                if (byte == 0xFF) {
                    tmp_data_idx_ = 0;
                    fsm_ = Fsm::kWaiForHeader;
                    return true;
                } else {
                    fsm_ = Fsm::kWaiForHeader;
                    return false;
                }
                break;
        }

        return false;
    }

    static Fsm fsm_;
    static size_t tmp_data_idx_;
};

DataProcesser::Fsm DataProcesser::fsm_ = DataProcesser::Fsm::kWaiForHeader;
size_t DataProcesser::tmp_data_idx_ = 0;

void Init(void)
{
    tx_rx1_ptr = new TxRx(0x01, 0x02);
    tx_rx2_ptr = new TxRx(0x02, 0x01);

    uart_rx_mgr_ptr = new comm::UartRxMgr(
        &huart6, comm::UartRxMgr::EofType::kManual, 14);

    /* 配置自定义处理函数 */
    uart_rx_mgr_ptr->registerProcessDataFunc(DataProcesser::ProcessData);
    uart_rx_mgr_ptr->addReceiver(tx_rx1_ptr);
    uart_rx_mgr_ptr->addReceiver(tx_rx2_ptr);

    uart_tx_mgr_ptr = new comm::UartTxMgr(&huart6, 13);
    uart_tx_mgr_ptr->addTransmitter(tx_rx1_ptr);
    uart_tx_mgr_ptr->addTransmitter(tx_rx2_ptr);

    rc_ptr = new remote_control::DT7;

    rc_rx_mgr_ptr = new comm::UartRxMgr(&huart3, comm::UartRxMgr::EofType::kIdle,
                                        remote_control::kRcRxDataLen + 1);
    rc_rx_mgr_ptr->addReceiver(rc_ptr);

    /* 开启接收 */
    uart_rx_mgr_ptr->startReceive();
    rc_rx_mgr_ptr->startReceive();
}

/* 以 1ms 为周期调用的函数 */
void Loop1ms(void)
{
    static uint32_t count = 0;
    count++;

    /* 定时发送 */
    if (count % 1000 == 0) {
        uart_tx_mgr_ptr->setTransmitterNeedToTransmit(tx_rx1_ptr);

        uart_tx_mgr_ptr->startTransmit();
    } else if (count % 1000 == 500) {
        uart_tx_mgr_ptr->setTransmitterNeedToTransmit(tx_rx2_ptr);

        uart_tx_mgr_ptr->startTransmit();
    }
}

/* 接收回调函数 */
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef* huart, uint16_t Size)
{
    uart_rx_mgr_ptr->rxEventCallback(huart, Size);
    rc_rx_mgr_ptr->rxEventCallback(huart, Size);
}

/* 错误回调 */
void HAL_UART_ErrorCallback(UART_HandleTypeDef* huart)
{
    uart_rx_mgr_ptr->errorCallback(huart);
    rc_rx_mgr_ptr->errorCallback(huart);
}

/* 发送回调函数 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef* huart)
{
    uart_tx_mgr_ptr->txCpltCallback(huart);
}
```

### 使用说明

#### UartTxMgr

该类用于实现 UART 的数据发送

- `txCpltCallback` 需放于 `HAL_UART_TxCpltCallback` 回调函数中，用与在完成一条报文的 DMA 发送后继续发送下一条报文
- `status` 用于获取 UART 发送管理器状态，通过位置位表示状态。

#### UartRxMgr

该类用于实现 UART 的数据接收

- `registerProcessDataFunc` 用于注册自定义数据处理函数，不注册则使用默认数据处理函数。
- `resetProcessDataFunc` 将数据处理函数修改为默认数据处理函数。
- `rxEventCallback` 需放于 `HAL_UARTEx_RxEventCallback` 回调函数中，用于在接收到数据有进行数据处理。
- `errorCallback` 需放于 `HAL_UART_ErrorCallback` 回调函数中，用于在因开启接收时因某些错误导致接收开启失败时重新开启接收，以确保接收能被开启。
- `status` 用于获取 UART 接收管理器状态，通过位置位表示状态。

UART 的帧判断分为**以空闲帧作为一帧结束**及**自行判断一帧结束**两种可选判断方式：
- 以空闲帧作为一帧结束：以空闲帧作为数据的分割，及以两次空闲帧间收到的数据作为一帧数据（**注意当两帧间隔过小时，两帧的间隔并不会被认为是空闲帧，在裁判系统的接收中极其容易遇到这种情况**）。
- 自行判断一帧结束：自行通过帧头帧尾对数据进行分割，推荐以此方式进行数据接收，因其具有处理两帧粘连的情况，但实际接收时传入数据处理函数的数据为经搬接收、全接收及空闲帧为分割的数据，因此需**自行编写状态机用于帧的分割与拼接**（**注意该方法仅使用于具有可用帧头帧尾进行分割的数据，像 DT7 遥控器的数据接收则不适用于该方法**）。

> **自定义数据处理函数**
> 对于自定义的数据处理函数， UART 接收管理器会在触发接受事件回调时将缓冲区中正确的数据取出，然后**传入自定义数据处理函数中**，同时**告知接收到的数据大小**，自定义数据处理函数需**返回传入数据中已处理的数据量**，并且返回**当前已处理的数据是否满足一帧**的要求，当满足一帧数据的要求时，还需**额外返回改帧数据的 ID、处理后的数据及数据大小**，随后 UART 接收管理器便会根据返回的 ID 查找对应的接收器，调用对应接收器的 `decode` 方法进行解码。
> 同时，为处理帧粘连的情况，假设接收到的数据为两帧粘连的结构，自定义数据处理函数需在**将第一帧数据取出后及时返回**，在 UART 接收管理器完成第一帧解包工作后，会将尚未处理的第二帧**再次传入**自定义数据处理函数，以确保第二帧也能被处理。
> 若不提供自定义数据处理函数，则会使用默认的数据处理函数，即直接将接收到的**原始数据传给 ID 为 0 的接收器**。

### 注意事项

1. **发送**的缓冲区大小仅需**略大于**所要发送的数据的最大长度。而接收缓冲区长度有具体要求，当选择以**空闲帧作为一帧的结束时**，缓冲区应**大于实际接受的数据，建议大一**（因全接受产生空闲帧时不会触发空闲帧的中断）；而当选着**自行判断一帧结束时**，缓冲区**不宜过大**，其长度保证使两次中断触发的间隔内数据能被正常处理完毕即可（建议为 32）。
2. 为确保发送与接收不会过分耗时，通信时使用了 DMA，而对于 H7 系列的 STM32 而言，CubeMx 默认生成的工程将把所有变量的位置配置于 DTCMRAM 中（读取数据速度更快），但 DMA 在该区域无法工作，即无法修改或是读取位于该区域的变量，进而导致无法正常工作。为此，UART 的发送与接收管理器在初始化时允许使用外部提供的数据作为数据的缓冲区，仅需保证提供的数据位于 DMA 可工作区域内。

#### H7 变量位置配置
对 H7 而言 DMA 可工作的区域**必须大于 0x24000000**（具体查看数据手册），因此需修改 CubeMx 生成的 STM32xxx_FLASH.ld 配置文件，具体方法为：

1. 在 `MEMORY` 中可看到 `RAM_D1` 区域满足位于 DMA 可工作范围内，将如下代码拷贝到 `SECTIONS` 之中（建议放 `._user_heap_stack` 后）

```
/* Define output sections */
SECTIONS
{
...

/* ADD RAM_D1 section */
.RAM_D1 :
{
. = ALIGN(4);
*(.RAM_D1)
*(.RAM_D1.*)
. = ALIGN(4);
} >RAM_D1

...
}
```

2. 在需要 DMA 工作的变量的声明后补上 `__section("RAM_D1.<VAR>")`（`<VAR>`为变量名，为方便在 `*.map` 文件中查找），比如：

```cpp
// uint8_t buf[32];
uint8_t buf[23] __section("RAM_D1.buf");
```

如此变量便可以编译到指定的位置上

> 变量及其编译位置可在 build 生成的 `*.map` 文件中直接搜索变量查看