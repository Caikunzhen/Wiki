# 嵌入式编程风格指南

![hh](https://img.shields.io/badge/version-1.0.0-green)

## 写在前面

作为一名电控组成员，最重要的作品便是为机器人系统编写的代码。我们希望它能够成为一种构筑现实的材料、沟通思想的桥梁，同时也希望它足够清晰、简明、流畅、优雅，准确地表达每一个改变世界的想法。

事实上，队员的编程风格迥异，这可能或已经导致：

* 代码含义不明、表达混乱，存在废弃代码和重复代码
* 编程风格夹杂，大大降低了代码的可读性
* 代码耦合严重，可复用的部分难以移植
* 工程合作难以进行
* 代码整理、归档没有统一的规范，不利于传承和开源

因此，我们基于权威而广泛使用的 Google 编程风格指南（C++），参考了华为公司的 C 语言规范、国产实时操作系统 RT-Thread 的风格指南，编写战队嵌入式编程风格（C语言）指南，旨在让所有电控队员获知统一、规范的编程风格，并尽量遵循该风格进行源码的贡献，编写简洁、可维护、可靠、可测试、高效、可移植的代码。

我们强烈建议使用面向对象的风格设计嵌入式程序。考虑到资源限制、效率需求、系统可靠性、代码传承、整体水平，目前我们主要使用 C 语言进行嵌入式开发，使用 `结构体 + 函数指针` 辅助实现 “类” 的概念。在系统核心层面以上的应用程序，允许使用 C++ 的小部分特性，即 `C with Class` 来实现。


> 规则的作用是避免混乱，但规则本身一定要权威，有说服力，并且是理性的。
>
> Google 保持其一贯的严谨精神，5 万汉字的指南涉及广泛，论证严密。我们翻译该系列指南的主因也正是其严谨。严谨意味着指南的价值不仅仅局限于它罗列出的规范，更具参考意义的是它为了列出规范而做的谨慎权衡过程。
>
> 指南不仅列出你要怎么做，还告诉你为什么要这么做，哪些情况下可以不这么做，以及如何权衡其利弊。其他团队未必要完全遵照指南亦步亦趋，如前面所说，这份指南是 Google 根据自身实际情况打造的，适用于其主导的开源项目，其他团队可以参照该指南，或从中汲取灵感，建立适合自身实际情况的规范。
>
> —— 摘自《Google 开源项目风格指南：C++ 风格指南》中文版译者序


## 1 头文件

### 原则

头文件是模块的对外接口，放置对外部的声明，如函数声明、宏定义、类型定义等。有以下原则：

* 变量定义，函数定义和内部函数声明不应出现在头文件中
* 变量声明 (即全局变量声明) 尽量不要出现在头文件中，如必须使用全局变量，应采用**函数接口**对外暴露
* 头文件应向稳定方向包含，如应用依赖于中间件，中间件依赖于底层库，又如模块依赖于接口
* 不允许头文件循环依赖，不允许包含用不到的头文件

### 规定

通常每一个 `.c` 文件都有一个对应的 `.h` 文件。也有一些常见例外，如一些仅用于配置组件的头文件。

#### 1.1 自包含

头文件应该能够自给自足，即一个头文件已经包含了它所需要的其他头文件，也不要求定义任何特别的符号，能够独立编译。

#### 1.2 重包含保护

所有头文件都使用 `#define` 保护来避免头文件被多重包含，命名格式如下:

```c
#ifndef __<FILE>_H_
#define __<FILE>_H_
/* header file content */
#endif /* __<FILE>_H_ */ 
```

若文件名中包含多个词，请采用 `_` 连接。

#### 1.3 内联函数定义

建议将内联函数定义在 `.h` 文件中。

> 由于内联函数要在调用点展开，编译器必须随处可见内联函数的定义，这要求每个调用了内联函数的文件都包含该内联函数的定义。此外，我们需要规避重复定义的风险。因此，最佳方案是将内联函数定义于头文件中。

更多关于内联函数的说明，请参考 [2.5 内联函数](#25)。

#### 1.4 头文件包含顺序

头文件包含顺序为: 

* C 标准库
* 其他库的 `.h` 文件
* 本项目内的 `.h` 文件

必要时，使用 `/* */` 格式的注释来分隔头文件组。各组内按首**字母升序**排列头文件。



## 2 函数

### 原则

函数设计应整洁、精简并有效组织，有以下原则：

* **整洁**：代码应简明直接，不隐藏设计意图，抽象干脆，操作直接
* **精简**：函数仅完成相对独立的简单功能，一个函数应仅完成单一功能
* **有效组织**：
    * 设计逻辑清晰，不同功能的函数关系合理，关注模块间接口和总体架构
    * 函数名应清晰体现功能的含义，易于查阅和理解
* 重复代码应尽可能提炼成函数
* 提供给外部使用的接口函数，必须在相应的头文件中声明

### 规定

#### 2.1 编写简短函数

避免函数过长，考虑将长函数分割为更加简短并易于管理的若干函数。一个量化标准是 50 行以内（非空非注释行）。

#### 2.2 避免嵌套过深

函数代码块嵌套深度指 `if, for, while, switch...` 等代码控制块之间相互包含的深度，应不超过 4 层。

#### 2.3 可重入函数的保护

当函数希望实现可重入特性，即可被多线程并发调用时，应避免使用全局变量和 `static` 局部变量，否则需要选择互斥手段进行保护：

* 关闭全局中断
* 在操作变量前申请信号量，操作完毕方可释放信号量

#### 2.4 内部函数

在单一源文件范围内声明和定义的所有函数，除非外部可见，否则都应增加 `static` 关键字修饰。

> 我们强烈建议使用面向对象的风格，在定义结构体类型时使用函数指针，在运行时绑定具体的函数，从而保护所有内部函数并实现面向对象的特性。关于具体实现形式，请参考 [5 类和对象](#5)。

#### 2.5 内联函数

> 当函数被声明为内联函数之后，编译器会将其在调用点展开，而不是按通常的函数调用机制进行调用。只要内联的函数体较小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性能关键的函数，鼓励使用内联。

内联关键字必须与函数定义体放在一起才能使函数成为内联，仅将关键字放在函数声明前面不起任何作用。

只有当函数只有 10 行甚至更少时，才建议将其定义为内联函数。内联函数内不可以有 `循环` 或 `switch` 语句，函数类型不可以为可变参数函数，函数定义中的某些用法可能使其不适合内联替换。

请注意，有些情况下函数即使被声明为内联也不一定会被编译器内联，具体参见 [GCC 官网说明](https://gcc.gnu.org/onlinedocs/gcc/Inline.html)。一般地，我们建议使用以下关键字，由编译器选择是否内联:

```c
static inline
__STATIC_INLINE                                /* 基于 CMSIS 封装的版本 */
```

若使用以下关键字，将强制内联:

```c
__attribute__((always_inline)) static inline
__STATIC_FORCEINLINE                           /* 基于 CMSIS 封装的版本 */
```

#### 2.6 参数合法性和错误处理

在接口函数中进行参数合法性检查，请采用 `assert_param`  或自定义 `ASSERT` 宏。同时，也需要检查所有非参数输入的有效性。

对于函数返回的错误码，应尽可能全面地处理。

#### 2.7 参数类型

使用 `const` 关键字修饰常量参数。如果函数入口参数是空，必须使用` void` 作为入口参数。

#### 2.8 高扇入，合理扇出

扇入（fan-in）指直接调用该函数的上级模块的数目，扇出（fan-out）函数调用其他模块的数目。高扇入意味着函数利用率较高，主要针对公用模块及底层函数的设计；合理扇出意味着控制和协调下级函数数量合理，功能清晰，主要针对应用层级和中间层的函数。若扇出太大，则可适当增加中间层次函数；反之则希望分解下级函数，使其功能划分更为清晰合理。

#### 2.9 及时清除废弃代码

请及时清理弃用的函数及测试用函数。



## 3 变量

### 原则

* 变量的含义应当简明清晰，不应用一个变量表示多种含义，也不应用作多种用途
* 结构体变量应明确地描述一个对象，而不是一组相关性不强的数据的集合
* **尽量不使用**外部可见的全局变量；允许在模块内部使用 `static` 变量
* 禁止使用未经初始化的变量作为表达式右值

### 规定

#### 3.1 外部访问变量

如果本模块数据需要对外部开放，则应提供函数接口来进行 `set ` / `get`，同时注意全局数据的访问互斥。

#### 3.2 类型转换

尽量减少无意义的类型转换，以避免数据类型转换带来的含义变化。对于默认类型转换，应进行注释说明，或使用强制转换符号标明。

#### 3.3 初始化

在首次使用前必须初始化变量，最安全的方案是在定义变量时进行初始化。初始化的值应当有实际意义。

#### 3.4 及时清除废弃变量

请及时清理弃用的变量及测试用变量。

### 建议

针对嵌入式开发，有以下建议：

* 当数据为无符号时，总是使用 `unsigned` 类型以节省存储空间
* 总是使用准确标明位数的整型
* 如果数据大小允许，请尽量使用 `float` 类型的浮点数

如：

```c
int8_t an_8bit_int_variable;   /* 8 位整型 */
uint32_t sys_tick;             /* 32 位无符号数 */
float a_float_variable;        /* 浮点数 */
```



## 4 宏和常量

### 规定

宏包括无参数宏、带参数宏。常量包括常量数（字）、字符（串）等。

#### 4.1 宏规范

使用宏定义表达式时，应使用完备的括号，如：

```c
#define AREA(a, b) ((a) * (b))
```

>  以上每个括号都是必要的。

当使用宏定义多条表达式时，应使用最安全的 `do ... while (0)` 写法，如：

```c
#define FOO(x)             \
    do {                   \
        printf("%s\n", x); \
        do_something(x);   \
    } while (0)
```

使用宏时，不允许参数发生变化，如不允许：

```c
#define SQUARE(a) ((a) * (a))

uint8_t a = 5u;
uint8_t b = SQUARE(a++); /* 不允许 */
```

尽量不在宏定义中使用可能改变程序流程的语句。

> 允许使用一些宏技巧，如用 `#` 进行字符串化、用 `##` 连接字符串、使用可变参数宏定义等，如：
>
>```c
>#define TO_STR(x) (#x)
>#define NEW_XN(n) x##n
>#define VA_MACRO(...) printf(__VA_ARGS__)
>```

#### 4.2 常量规范

不允许直接使用含义不直观的数（字）。对于局部使用的唯一数（字），请在注释中写明其含义；如果一个有含义的数（字）需要在多处使用，尽可能将其定义为 `const` 常量，变量名即代表其含义。

对于广泛使用的数（字），可在头文件中定义 `static const` 类型常量。

#### 4.3 预定义宏

编译器支持标准预定义宏：

| 宏            | 描述                                                         |
| :------------ | ------------------------------------------------------------ |
| `__cplusplus` | 当翻译单元编译为 C++ 时，定义为整数文本值。 其他情况下则不定义。 |
| `__DATE__`    | 当前日期，一个以 "`MMM DD YYYY`" 格式表示的字符串常量。      |
| `__TIME__`    | 当前时间，一个以 "`HH:MM:SS`" 格式表示的字符串常量。         |
| `__FILE__`    | 当前源文件的名称。 `__FILE__` 展开为字符型字符串文本。       |
| `__LINE__`    | 当前源文件中的整数行号，一个十进制常量。                     |
| `__STDC__`    | 判断当前的编译器是否为标准C编译器，若是则返回值1             |
| `__FUNC__`    | 函数名（非标准）                                             |

CMSIS 组件对编译器的特定宏定义封装，常用的有：

| 宏                     |
| :--------------------- |
| `__STATIC_INLINE`      |
| `__STATIC_FORCEINLINE` |
| `__WEAK`               |
| `__PACKED`             |
| `__PACKED_STRUCT`      |
| `__PACKED_UNION`       |

### 建议

#### 4.4 谨慎使用宏

使用宏时要谨慎，尽量以内联函数,、枚举和常量代替宏。宏缺乏类型检查，且展开时可能会产生意想不到的副作用，尤其因为宏具有全局作用域。

##### 使用函数替代宏

以宏形式编写的代码语句难以调试和设置断点，不利于定位问题；若宏调用多，可能造成代码空间的浪费。因此，应尽可能使用函数代替宏；对于简短的多条语句宏，可遵循内联函数的规范，改写为内联函数。

##### 使用常量代替宏

考虑到宏的潜在危险，以及宏定义符号名并不会进入编译阶段，可能使编译阶段的报错信息含义模糊，应尽可能使用 `const` 常量及常量指针。

#### 4.5 充分使用常量

`const` 类型的变量、数据成员和参数为编译时类型检测增加了一层保障，便于尽早发现错误；编译器可以更好地进行类型检测，相应地，能够生成更安全的代码；我们也能够更容易理解如何使用变量。因此，建议对于任何在程序运行期间其值始终保持不变的变量、初始化后不会被修改的结构体成员、不会被函数修改的参数，在声明或参数前添加 `const` 标识符。



## 5 面向对象

面向对象是一种思想和设计方法。C 语言是面向过程的语言，但经过适当的设计，能够实现面向对象的特性：封装，继承，多态，以更好地适用于复杂项目的开发。

面向对象思想一方面考虑了现实世界与面向对象空间的映射关系，更符合人类思维习惯；另一方面考虑了结构化程序设计的优点，具有模块化、高内聚、低耦合的特性，降低了维护成本、提升了代码复用程度，能使得程序的架构更加清晰，系统更灵活、更易扩展。以使用 C 语言开发的 Linux 内核为例，其对于面向对象思想的大量运用，以及对程序架构和编码风格的严苛要求，使其历经数十年迭代依然保持健康和活力。

### 建议

我们强烈建议使用面向对象的风格设计嵌入式程序。

#### 5.1 基本概念

一个实体对象被抽象为类，使用结构体表示类，结构体内的所有变量作为类的属性。由于 C 语言的函数不能在结构体内定义，实际上我们的方法定义在类的外部，在类的内部定义函数指针进行链接，具体而言：

* 在结构体内定义函数指针，使用 `动词短语` 的格式命名操作对象的方法。函数的实现在构造（初始化）时绑定，也允许在后续在运行时根据用户给出的指示“动态绑定”。对于构造函数，需要在结构体外部声明。
* 继承时，子类能够重写父类的方法，具体实现上采用“虚表”的形式，在构造时注册函数指针列表。
* 针对多态的实现，可以在结构体外定义基类方法，允许引用任何子类对象。使用 `类名 + 动词短语` 的格式命名。

一个较为完整的实现面向对象特性的 C 语言写法如下所示。在实际开发中，可仅实现需要的特性。

```c

/* 类定义 -----------------------------------------------------------------------*/
/* 虚表类型定义 */
#ifdef USING_VIRTUAL_TABLE
typedef struct DeviceOps DeviceOps_t;
struct DeviceOps
{
    void (*start)(Device_t* device);
    void (*stop)(Device_t* device);
};
#endif /* USING_VIRTUAL_TABLE */

typedef struct Device Device_t;
struct Device
{
    /* 属性 */
    Object_t parent;
    char name[NAME_MAX_LEN];
    SysTick_t time;

    /* other fields */
    
    /* 方法 */
    SysTick_t (*getTime)(Device_t* device); /* 访问器 */
    void (*setTime)(Device_t* device, SysTick_t time); /* 修改器 */
#ifdef USING_VIRTUAL_TABLE
    /* 虚表指针 */
    DeviceOps_t* ops;
#else
    void (*start)(Device_t* device);
    void (*stop)(Device_t* device);
#endif /* USING_VIRTUAL_TABLE */
};

/* 构造函数声明 */
void DeviceCreate(Device_t* device, const char* name, SysTick_t time, DeviceOps_t* ops, ...);

/* 需要多态时，供子类调用，引用任何子类，访问父类方法 */
#ifdef USING_VIRTUAL_TABLE
void DeviceStart(void* any);
void DeviceStop(void* any);
#endif /* USING_VIRTUAL_TABLE */

/* 方法实现 ----------------------------------------------------------------------*/
static void Start(Device_t* device) { ... }
static void Stop(Device_t* device) { ... }

DeviceOps_t device_ops = {Start, Stop};

#ifdef USING_VIRTUAL_TABLE
/* 供子类调用，以实现多态 */
void DeviceStart(void* any)
{
    Device_t* device = (Device_t*)any;
    device->ops->start(device);
}

void DeviceStop(void* any)
{
    Device_t* device = (Device_t*)any;
    device->ops->stop(device);
}
#endif /* USING_VIRTUAL_TABLE */

/* 构造函数实现 --------------------------------------------------------------------*/
void DeviceCreate(Device_t* device, const char* name, SysTick_t time, DeviceOps_t* ops, ...)
{
    /* 构造父类 */
    Object* parent = (Object*)device; /* 强制类型转换，以访问父类 */
    ObjectCreate(parent, ...);

    /* 绑定方法 */
    device->getTime = TimerGetTime;
    device->setTime = TimerSetTime;
#ifdef USING_VIRTUAL_TABLE
    if (ops === NULL) {
        /* 父类方法，虚表形式 */
        device->ops = &device_ops;
    } else {
        /* 继承，虚表指针指向子类虚表，方法被子类重写 */
        device->ops = ops;
    }
#else
    /* 不需要继承，简单形式 */
    device->start = Start;
    device->stop = Stop;
#endif /* USING_VIRTUAL_TABLE */

    /* other initializing operations */
}
```

#### 5.2 封装

封装对类相关的数据和方法进行打包，着重描述数据的组织形式，并隐藏数据及方法。与 C++ 的类对数据的封装相比较，C 语言所使用的结构体天然具有这种特性，只是无法定义权限修饰符；我们可以用是否为属性创建访问器和修改器的形式，来定义一个属性是否可被外部操作。对一个类进行数据封装时，应充分考虑数据间的层次关系和相关性。

围绕数据和对象的特性，我们为对应类添加方法。在 C++ 中，当调用一个对象的方法时，编译器会自动将对象的地址传递给隐含的 `this` 指针；在 C 语言中，则需要我们显式地定义 `this` 指针，并在调用时主动把对象的地址传递给它。

在以上代码段中，`Device` 类的所有属性和方法被封装。

#### 5.3 继承

继承描类之间的关系，使得子类自动拥有父类的属性和方法并拥有新的特性，这有利于代码的重用和纵向的对象关系组织。C 语言中，如果我们在子类结构体中首个成员变量的位置放置一个父类结构体变量，那么我们便可以通过对结构体指针进行强制类型转换来访问父类对象，从而实现继承。

在构造（初始化）子类对象时，递归构造父类对象，然后初始化子类的成员。

在以上代码段中，`Device` 类作为子类，继承自 `Object` 类。实例化时，我们首先创建一个 `Device` 类型的对象 `device`，然后调用 `DeviceCreate` 方法对其进行初始化，其中显式地调用了父类的构造方法。

#### 5.4 多态

多态描述程序运行时的动态行为，允许使用任何子类实例作为实参，并根据子类的类型调用对应的方法。在 C++ 中，虚函数实现了多态特性，具体实现方式为编译阶段在类中添加虚表指针用于指向虚函数表，在运行时动态绑定要调用的函数。C 语言中，我们将手动实现，在父类中放置一个虚表指针，子类继承时便可以令继承而来的虚表指针指向自己的虚表，进而实现多态。

在以上代码段中，`Device` 类作为父类，其中定义了虚表指针 `DeviceOps_t* ops`，当有子类继承它时，若给出了虚表，则虚表指针将指向该虚表，相当于重写了父类方法。

*函数重载*

C 语言不支持重载特性，但适当地使用可变参数函数，能达到类似重载的效果。

#### 5.5 抽象

充分使用抽象类，能够提取一类事物的特征构成对象，进而为用户提供统一接口。

若使用纯虚函数，而子类未实现方法，则可以绑定一个异常处理的函数，能够检测非法的方法使用情况，如：

```c
/* 给出非法访问处理函数表，供非法调用纯虚函数时进行断言 */
DeviceOps_t ops_invalid = {Invalid, Invalid};

void Invalid(Device_t* device)
{
    assert(0);
}

void DeviceCreate(Device_t* device, const char* name, SysTick_t time, DeviceOps_t* ops, ...)
{
    ...

    /* 纯虚函数，而子类未给出虚表即未实现，赋给非法访问处理表 */
    if(ops == NULL) {
        device->ops = &ops_invalid;
    }

    ...
}
```

#### 5.6 动态创建对象

在创建一个新的对象时，应思考清楚对象的内存操作处理：是否允许一个静态对象存在，或仅仅支持从堆中动态分配的对象。根据实际情况选择是否支持动态创建对象，并注意对 `malloc` 和 `free` 及类似方法的安全使用。

## 6 命名约定

### 原则

命名具有一定随意性，但相比按个人喜好命名，一致性更为重要。因此，我们对代码设计的命名提出约定，目的是让团队的代码尽可能统一，以及让我们在不需要查找类型声明的情况下快速区分命名代表的含义：类型，变量，函数，常量，宏等等，以利于后续阅读和修改。有以下原则：

* 保持一致性
* 命名应具有描述性，清晰且具有明确含义

### 规定

#### 6.1 通用命名规则

使用完整的英文单词或易于理解的缩写，以避免误解；不得使用汉语拼音。常见的通用缩写请参考 [附录A 英文单词缩写参考](#a)，使用其他缩写时请仔细斟酌是否表意清晰、易于理解。例如：

```c
price_count_reader  /* 好: 无缩写 */
num_err             /* 好: "num" "err" 均是常见的缩写 */
n                   /* 坏: 使用随意的字符，意义模糊 */
n_comp_conn         /* 坏: 意义不明的缩写 */
```

#### 6.2 文件命名

##### 目录名称

目录名称应能够反映目录下全部文件的总体含义。目录名称统一采用 `全小写` 格式，使用 `_` 来连接单词，如：

```c
middlewares
include
dev_mgmt
```

##### 文件名称

文件名称统一采用 `全小写` 格式，使用 `_` 来连接单词，如：

```c
board.c
dev_mgmt.h
```

另外为避免文件重名的问题，请尽量不要使用通用化、使用频率高的名称。若是使用了现有的库或现有工具生成的目录，请不要修改。

#### 6.3 类型命名

类型包括结构体、枚举，以及类型定义（typedef）。类型名称统一采用 `单词首字母大写` 格式，单词间无连接符号（大驼峰）。对于类型定义，最末尾还需要添加 `_t`  标识，如：

```c
/* 结构体和枚举 */
struct MyExcitingStruct { ...
enum MyExcitingEnum { ...
/* 类型定义 */
typedef struct MyExcitingClass MyExcitingClass_t;
typedef enum MyExcitingEnum MyExcitingEnum_t;
```

#### 6.4 变量命名

应使用 `名词` 或 `形容词 + 名词` 的方式命名变量。**不应该**使用单字节命名变量，但一些特定的广为人知的简单定义被允许，如 `i, j, k` 表示局部迭代变量等。

变量名称统一采用 `全小写` 格式，使用 `_` 来连接单词，如：

```c
a_local_variable
a_struct_data_member
```

#### 6.5 函数命名

使用要执行的动作命名函数。函数名称主要采用`单词首字母大写` 格式，单词间无连接符号（大驼峰），如：

```
AddTableEntry()
```

对于首字母缩写的单词，更倾向于将它们视作一个单词进行首字母大写。对于模块对应”类“的方法的实现，使用 `ClassMethod` 格式，初始化函数使用 `ClassInit` 格式。如：

```c
UartGetData()           /* 类方法实现, Class = Uart, Method = GetData */
OledInit()              /* 而不是 OLEDInit() */
```

> 对于仅模块内部使用的静态函数，建议添加 `_` 前缀。如：`static _GetTableNum()`

对于函数指针，当其独立定义时，需要添加 `p` 前缀；但对于结构体内的函数指针，可采用首单词小写的方式来标识（小驼峰）。如：

```c
(*pSetColorHook)()      /* 独立定义的函数指针 */
(*setInfo)()            /* 结构体内的函数指针 */
```

#### 6.6 常量命名

常量（声明为 `const` 的变量）命名需要添加 `k` 前缀，之后采用 `单词首字母大写` 格式，单词间无连接符号，如:

```c
const uint8_t kDaysInAWeek = 7u;
```

#### 6.7 宏命名

宏定义统一采用采用 `全大写` 格式，使用 `_` 来连接单词，如：

```c
#define CTRL_FREQ (1000.0f)
#define ROUND(x) ... 
```

除了头文件或编译开关特殊标识定义，宏定义不能使用 `_` 开头和结尾。

#### 6.8 枚举命名

枚举命名和宏一致，统一采用采用 `全大写` 格式，使用 `_` 来连接单词，如：

```c
enum AlternateUrlTableErrors {
    OK = 0u,
    OUT_OF_MEMORY = 1u,
    MALFORMED_INPUT = 2u,
};
```



## 7 注释

请使用 `英文` 进行注释。使用中文注释将意味着在编写代码时需要来回不停的切换中英文输入法从而打断编写代码的思路，且经常发生编码格式问题；同时，英文注释更有利于开源和交流。

有以下原则：

* 源码的注释不应过多，完美的代码应尽可能做到不需要注释即可被轻松读懂，这对编码提出了更高的要求
* 注释不应重复描述代码、翻译代码，而应解释代码难以直接表达的意图，或在个别关键点使用提示性的注释以解释一段复杂的算法是如何工作的

### 规定

在注释中，应避免使用缩写。完整注释模板请参考[附录B：注释模板](#b)，建议使用该模板或类似的格式创建注释。

#### 7.1 头部注释

文件头部应添加说明注释，列出：文件名、文件说明、版本号、修改日期、作者姓名、修改日志、其他注意事项及版权声明等信息。下方给出了一个模板头部注释：

```c
/**
 *******************************************************************************
 * @file      : <file>.c/h
 * @brief     : 
 * @history   :
 *  Version     Date            Author          Note
 *  V0.9.0      yyyy-mm-dd      <author>        1. <note>
 *******************************************************************************
 * @attention :
 *******************************************************************************
 *  Copyright (c) 2022 Hello World Team, Zhejiang University.
 *  All Rights Reserved.
 *******************************************************************************
 */
```

#### 7.2 函数注释

重要或复杂内部函数定义、提供外部使用的函数定义和声明的上方应添加函数注释，列出：函数功能、输入参数和可能的参数值、返回值和其他说明和要求。对于独立函数指针和结构体的函数指针成员，也应采用函数注释。下方给出了一个模板函数注释：

```c
/**
 * @brief       <brief>
 * @param       <param>
 *   @arg       <arg>
 * @retval      <retval>
 * @note        <note>
 */
```

#### 7.4 变量注释

对于模块内的 `static` 变量，及不得不使用的外部可见的全局变量，应提供注释说明，包括对其功能含义、取值范围、存取注意事项等的说明。

对于结构体中的每个成员，其含义和用途无法用变量名称完全描述的，需要在其**右方**添加说明注释。

#### 7.5 语句注释

对语句的注释只能放置在其**上方或右方**，若放于上方应与其上面的代码用空行隔开。如：

```c
... /* comments */
... // comments

/* comments */
... 
```

#### 7.6 TODO 注释

对于临时的，短期的解决方案，或已经够好但仍不完美的代码，使用 `TODO` 注释。`TODO` 注释要使用全大写的字符串 `TODO`，在随后的圆括号里写上你的名字或其它身份标识，主要目的是便于根据规范的 `TODO` 格式进行查找。请尽可能记录与这一 `TODO` 相关的问题或事项。如：

```c
// TODO(Hello World): remove the "last visitors" feature
```



## 8 格式

### 规定

每个人都可能有自己的代码格式，但整个项目的代码格式统一是很重要的，只有这样才能让所有人轻松地阅读和理解代码。格式的规定非常冗杂，在这里我们直接参考使用 [Google 风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/) 的 “格式” 部分，并做些许改动。改动部分将在 [9 自动格式化](#9) 列出。

我们可以使用一些工具来自动化地配置代码格式，如 [Clang-Format](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)，该工具允许将格式配置为 "Google Style"。 `CLion` 和 `Visual Studio Code` 均可使用该工具，具体的说明见 [9 自动格式化](#9)。

在本节，只简明扼要地指出几个自动工具无法涉及的格式规定及一些争议规定。

### 8.1 缩进

与 Google 格式规范不同，我们规定程序块每级缩进为 **4** 个空格，`Tab` 对应 **4** 个空格。请开启编辑器 / IDE 的 `Tab` 转空格功能。

### 8.2 行长度

与 Google 格式规范不同，我们对每行代码最大字符数不做限定，但建议保持在 **120** 以内.

### 8.3 字符编码

统一采用 `UTF-8` 编码。

### 8.4 空行

相对独立的程序块之间、变量说明之后应添加空行。

### 8.5 注释

注释符和注释内容之间用一个空格进行分隔。

### 建议

#### 注释格式

建议文件头部注释、函数注释、全局及常量变量、类型定义的注释格式采用工具可识别的格式，可用于后期由注释直接导出代码说明文档，如 [Doxygen 格式](https://www.doxygen.nl/manual/docblocks.html)。我们给出的注释模板符合该格式。



## 9 自动格式化

我们在 Google 格式规范的基础上做出以下修改：

* 花括号前换行的设置设为 Linux 风格，即函数换行，其他情况不换行
* 代码块缩进 4 个空格
* `Tab` 对应 4 个空格
* 不允许在一行中使用简短的 if 语句写法
* 每行代码最大字符数不做硬性要求，但建议控制在 120 以内

### 9.1 VS Code 格式化插件

使用 `Visual Studio Code` 的 `C/C++` 插件，能够自动格式化代码，使其符合格式规范。安装插件后，建议配置如下：

* 打开设置（`Ctrl` + `,`），搜索：

  ```
  C_Cpp.clang_format_fallbackStyle
  ```

* 粘贴以下配置：

  ```
  { BasedOnStyle: Google,  BreakBeforeBraces: Linux,  UseTab: Never, IndentWidth: 4, TabWidth: 4, AllowShortIfStatementsOnASingleLine: false, ColumnLimit: 0}
  ```

  ![image-20221217015517877](./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97.assets/image-20221217015517877.png)

使用 `Alt` + `Shift` + `F` 进行格式化，或进行以下设置，在保存时自动格式化：

* 打开设置（`Ctrl` + `,`），搜索：

  ```
  editor.formatOnSave
  ```

* 进行以下配置：

  ![image-20221217020730346](./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97.assets/image-20221217020730346.png)

### 9.2 VS Code 快速生成注释插件

使用 `Visual Studio Code` 的 `koroFileHeader` 插件，经过配置，能够快速生成文件头部注释和函数注释。安装插件后，建议配置如下：

* 注释快捷键很可能冲突，请自行设置快捷键。使用 `Ctrl K + Ctrl S` 唤出键盘快捷方式菜单，搜索快捷键，共有两个：头部注释，命令 ID 为 `extension.fileheader`；函数注释，命令 ID 为 `extension.cursorTip`.

* 在全局 `settings.json` 用户设置文件中进行字段配置，配置模板可参考 [附录C：koroFileHeader 配置](#c-korofileheader).

  ![image-20221217021400943](./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97.assets/image-20221217021400943.png)



## 附录

### A 英文单词缩写参考

| 单词          | 缩写         |
| ------------- | ------------ |
| argument      | arg          |
| buffer        | buff         |
| clock         | clk          |
| command       | cmd          |
| communicate   | comm         |
| compare       | cmp          |
| configuration | config / cfg |
| device        | dev          |
| driver        | drv          |
| error         | err          |
| frequency     | freq         |
| include       | inc          |
| initialize    | init         |
| management    | mgmt         |
| maximum       | max          |
| message       | msg          |
| minimum       | min          |
| module        | mod          |
| parameter     | para         |
| previous      | prev         |
| protocol      | prot         |
| register      | reg          |
| repository    | repo         |
| semaphore     | sem          |
| source        | src          |
| synchronize   | sync         |
| temp          | tmp          |
| utility       | util         |

### B 注释模板

#### 文件头部注释

`.c`

```c
/**
 *******************************************************************************
 * @file      : <file>.c
 * @brief     : 
 * @history   :
 *  Version     Date            Author          Note
 *  V0.9.0      yyyy-mm-dd      <author>        1. <note>
 *******************************************************************************
 * @attention :
 *******************************************************************************
 *  Copyright (c) 2022 Hello World Team, Zhejiang University.
 *  All Rights Reserved.
 *******************************************************************************
 */
/* Includes ------------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private constants ---------------------------------------------------------*/
/* Private types -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* External variables --------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
```

`.h`

```c
/**
 *******************************************************************************
 * @file      : <file>.h
 * @brief     :
 * @history   :
 *  Version     Date            Author          Note
 *  V0.9.0      yyyy-mm-dd      <author>        1. <note>
 *******************************************************************************
 * @attention :
 *******************************************************************************
 *  Copyright (c) 2022 Hello World Team, Zhejiang University.
 *  All Rights Reserved.
 *******************************************************************************
 */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __<file>_H_
#define __<file>_H_

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
/* Exported macro ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
/* Exported variables --------------------------------------------------------*/
/* Exported function prototypes ----------------------------------------------*/

#ifdef __cplusplus
}
#endif

#endif /* __<file>_H_ */
```

#### 函数注释

```c
/**
 * @brief       <brief>
 * @param       <param>
 *   @arg       <arg>
 * @retval      <retval>
 * @note        <note>
 */
```

### C `koroFileHeader` 配置 

```json
    // koloFileHeader -------------------------------------------------
    // 头部注释
    "fileheader.customMade": {
        "custom_string_obkoro9": "******************************************************************************",
        "FilePath": "only file name",
        "Description": "",
        "custom_string_obkoro1": " @history   :",
        "custom_string_obkoro2": "  Version     Date            Author          Note",
        "custom_string_obkoro3": "  V0.9.0      yyyy-mm-dd      <author>        1. <note>",
        "custom_string_obkoro10": "******************************************************************************",
        "custom_string_obkoro11": " @attention :",
        "custom_string_obkoro4": "******************************************************************************",
        "custom_string_obkoro1_copyright": "  Copyright (c) ${now_year} Hello World Team, Zhejiang University.",
        "custom_string_obkoro5": "  All Rights Reserved.",
        "custom_string_obkoro7": "******************************************************************************"
    },
    // 函数注释
    "fileheader.cursorMode": {
        "Description": "",
        "param": "", // param 开启函数参数自动提取 需要将光标放在函数行或者函数上方的空白行
        " @arg": "None",
        "return": "",
        " @note": "None"
    },
    "fileheader.configObj": {
        "prohibitAutoAdd": ["md", "json"],
        "dateFormat": "YYYY-MM-DD",
        "autoAdd": false, // 默认开启
        "autoAddLine": 1, // 默认文件超过100行就不再自动添加头部注释
        "createHeader": false, // 默认关闭
        "language": {
            // 一次匹配多种文件后缀文件 不用重复设置
            "h/c/hpp/cpp": {
                "head": "/** ", // 统一增加几个*号
                "middle": " *",
                "end": " */"
            }
        },

        "wideSame": true, // 头部注释等宽设置
        "wideNum": 12, // 头部注释字段长度
        "functionWideNum": 14, // 0 默认关闭 设置一个正整数即可开启 比如12
        "specialOptions": {
            "FilePath": " @file  ",
            "Description": " @brief   ",
            "param": " @param",
            "return": " @retval"
        },

        "afterAnnotation": {
            "c": "/* Includes ------------------------------------------------------------------*/\n/* Private macro -------------------------------------------------------------*/\n/* Private constants ---------------------------------------------------------*/\n/* Private types -------------------------------------------------------------*/\n/* Private variables ---------------------------------------------------------*/\n/* External variables --------------------------------------------------------*/\n/* Private function prototypes -----------------------------------------------*/\n",
            "cpp": "/* Includes ------------------------------------------------------------------*/\n/* Private macro -------------------------------------------------------------*/\n/* Private constants ---------------------------------------------------------*/\n/* Private types -------------------------------------------------------------*/\n/* Private variables ---------------------------------------------------------*/\n/* External variables --------------------------------------------------------*/\n/* Private function prototypes -----------------------------------------------*/\n",
            "h": "/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __FILE_H_\n#define __FILE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n/* Exported macro ------------------------------------------------------------*/\n/* Exported constants --------------------------------------------------------*/\n/* Exported types ------------------------------------------------------------*/\n/* Exported variables --------------------------------------------------------*/\n/* Exported function prototypes ----------------------------------------------*/\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __FILE_H_ */",
            "hpp": "/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __FILE_H_\n#define __FILE_H_\n/* Includes ------------------------------------------------------------------*/\n/* Exported macro ------------------------------------------------------------*/\n/* Exported types ------------------------------------------------------------*/\n#endif /* __FILE_H_ */"
        }, // 头部注释之后插入内容

        "atSymbol": ["@", "@"], // 所有文件的头部注释和函数注释的默认值
        "atSymbolObj": {},
        "colon": [": ", ""], // 所有文件的头部注释和函数注释的默认值
        "colonObj": {},
        "openFunctionParamsCheck": true, // 默认开启
        "typeParamOrder": "param",
        "functionParamsShape": ["", ""], // [] or {}
        "functionParamAddStr": ":", // 默认不增加字符串
        "functionTypeSymbol": "None" // 参数没有类型时的默认值
    },
```

### D 参考资料

[1] [Google 开源项目风格指南（C++ 部分）](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/)

[2] [华为技术有限公司 C 语言编程规范](./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97.assets/%E5%8D%8E%E4%B8%BA%E6%8A%80%E6%9C%AF%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8c%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83.pdf)

[3] [RT-Thread 编程风格](./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97.assets/coding_style_cn.txt)

### E 版本说明

| 版本号                                                       | 发布日期   | 说明     | 贡献者 |
| ------------------------------------------------------------ | ---------- | -------- | ------ |
| <img src = "https://img.shields.io/badge/version-1.0.0-green" > | 2022.12.17 | 首次发布 | 薛东来 |
